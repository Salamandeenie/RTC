<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Host/Join Example</title>
</head>
<body>
    <h1>WebRTC Room</h1>

    <button id="hostButton">Host a Room</button>
    <button id="joinButton">Join a Room</button>

    <input id="roomIdInput" type="text" placeholder="Enter Room ID to Join" />
    <button id="connectButton">Connect</button>

    <p id="status"></p>

    <script>
        const hostButton = document.getElementById('hostButton');
        const joinButton = document.getElementById('joinButton');
        const connectButton = document.getElementById('connectButton');
        const roomIdInput = document.getElementById('roomIdInput');
        const status = document.getElementById('status');

        let peerConnection;
        let dataChannel;
        let signalingSocket;
        let roomId = null;

        // Signaling server connection
        function connectToSignalingServer() {
            signalingSocket = new WebSocket('ws://localhost:8080'); // Replace with your signaling server

            signalingSocket.onmessage = (message) => {
                const data = JSON.parse(message.data);

                switch (data.type) {
                    case 'room-created':
                        roomId = data.roomId;
                        status.textContent = `Room created! ID: ${roomId}`;
                        break;

                    case 'peer-connected':
                        status.textContent = 'Peer connected. Negotiating WebRTC connection...';
                        createOffer();
                        break;

                    case 'joined-room':
                        status.textContent = `Joined room ${data.roomId}. Negotiating WebRTC connection...`;
                        break;

                    case 'signal':
                        handleSignal(data.signal);
                        break;

                    case 'error':
                        status.textContent = `Error: ${data.message}`;
                        break;
                }
            };
        }

        // WebRTC setup
        function setupWebRTC() {
            peerConnection = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            });

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    signalingSocket.send(JSON.stringify({
                        type: 'signal',
                        signal: { candidate: event.candidate },
                        targetRoom: roomId
                    }));
                }
            };

            // Handle data channel events
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                dataChannel.onmessage = (e) => {
                    console.log('Received message:', e.data);
                };
            };

            // If you're hosting, create the data channel
            if (!dataChannel) {
                dataChannel = peerConnection.createDataChannel('chat');
                dataChannel.onmessage = (event) => {
                    console.log('Received message:', event.data);
                };
            }
        }

        // Host a room
        hostButton.onclick = () => {
            connectToSignalingServer();
            signalingSocket.onopen = () => {
                signalingSocket.send(JSON.stringify({ type: 'create-room' }));
                setupWebRTC();
            };
        };

        // Join a room
        joinButton.onclick = () => {
            const roomToJoin = prompt('Enter room ID:');
            if (roomToJoin) {
                connectToSignalingServer();
                roomId = roomToJoin;
                signalingSocket.onopen = () => {
                    signalingSocket.send(JSON.stringify({
                        type: 'join-room',
                        roomId: roomId,
                        peerId: 'somePeerId'
                    }));
                    setupWebRTC();
                };
            }
        };

        // Handle WebRTC offer creation (Host)
        async function createOffer() {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            signalingSocket.send(JSON.stringify({
                type: 'signal',
                signal: { sdp: peerConnection.localDescription },
                targetRoom: roomId
            }));
        }

        // Handle WebRTC answer creation (Peer)
        async function createAnswer(offer) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            signalingSocket.send(JSON.stringify({
                type: 'signal',
                signal: { sdp: peerConnection.localDescription },
                targetRoom: roomId
            }));
        }

        // Handle incoming signaling data
        async function handleSignal(signal) {
            if (signal.sdp) {
                if (signal.sdp.type === 'offer') {
                    await createAnswer(signal.sdp);
                } else if (signal.sdp.type === 'answer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp));
                }
            }

            if (signal.candidate) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
            }
        }

        // Example message sending (from host or peer after connection)
        connectButton.onclick = () => {
            if (dataChannel) {
                dataChannel.send('Hello from the client!');
            }
        };
    </script>
</body>
</html>
