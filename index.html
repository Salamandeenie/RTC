<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Peer Connection</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #ipDisplay, #errorMsg {
            font-size: 24px;
            margin-top: 20px;
        }
        #status {
            margin-top: 20px;
            font-size: 18px;
        }
        #connectInput {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div>
        <button id="getIPBtn">Get My IP</button>
        <div id="ipDisplay">Your IP: <span id="ip"></span></div>
        <input type="text" id="connectInput" placeholder="Enter target IP address" />
        <button id="connectBtn">Connect to Peer</button>
        <div id="status">Status: Not Connected</div>
        <div id="errorMsg" style="color: red;"></div>
    </div>

    <script>
        let localPeerConnection;
        let remotePeerConnection;

        // STUN server to get the public IP address
        const stunServer = {
            urls: 'stun:stun.l.google.com:19302'
        };

        // Function to validate IP address
        function isValidIP(ip) {
            const ipPattern = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
            return ipPattern.test(ip);
        }

        // Get the public IP address using WebRTC
        function getPublicIP(callback) {
            const peerConnection = new RTCPeerConnection({ iceServers: [stunServer] });
            peerConnection.createDataChannel('dataChannel');
            peerConnection.createOffer().then(offer => {
                return peerConnection.setLocalDescription(offer);
            });

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    const candidate = event.candidate.candidate;
                    const parts = candidate.split(' ');
                    const ip = parts[4]; // The public IP address
                    callback(ip);
                }
            };
        }

        // Display the IP address
        document.getElementById('getIPBtn').onclick = () => {
            getPublicIP(ip => {
                document.getElementById('ip').textContent = ip;
                document.getElementById('errorMsg').textContent = ''; // Clear any previous errors
            });
        };

        // Connect to a target peer
        document.getElementById('connectBtn').onclick = () => {
            const targetIP = document.getElementById('connectInput').value;
            const errorMsg = document.getElementById('errorMsg');
            errorMsg.textContent = ''; // Clear previous error messages

            if (!isValidIP(targetIP)) {
                errorMsg.textContent = 'Error: Invalid IP address format.';
                return;
            }

            localPeerConnection = new RTCPeerConnection({ iceServers: [stunServer] });
            remotePeerConnection = new RTCPeerConnection({ iceServers: [stunServer] });

            // Create data channel
            const dataChannel = localPeerConnection.createDataChannel('dataChannel');

            // When the remote peer receives an ICE candidate, add it to the remote peer connection
            localPeerConnection.onicecandidate = event => {
                if (event.candidate) {
                    remotePeerConnection.addIceCandidate(event.candidate);
                }
            };

            // When remote peer connection receives an ICE candidate
            remotePeerConnection.onicecandidate = event => {
                if (event.candidate) {
                    localPeerConnection.addIceCandidate(event.candidate);
                }
            };

            // Create offer and set local description
            localPeerConnection.createOffer().then(offer => {
                return localPeerConnection.setLocalDescription(offer);
            }).then(() => {
                return remotePeerConnection.setRemoteDescription(localPeerConnection.localDescription);
            }).then(() => {
                return remotePeerConnection.createAnswer();
            }).then(answer => {
                return remotePeerConnection.setLocalDescription(answer);
            }).then(() => {
                return localPeerConnection.setRemoteDescription(remotePeerConnection.localDescription);
            }).then(() => {
                // Successful connection
                document.body.style.backgroundColor = 'black';
                document.getElementById('status').textContent = 'Status: Connected';
            }).catch(error => {
                console.error('Error establishing connection:', error);
                errorMsg.textContent = 'Error: Connection failed.';
            });
        };
    </script>
</body>
</html>
